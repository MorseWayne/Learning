---
title: 基础介绍
icon: /assets/icons/article.svg
order: 1
category:
  - Network
---

## 1 协议简介

**HTTP**(Hypertext Transfer Protocol, 超文本传输协议)是一种用来传输**超媒体文档**(hypermedia, 主要是是指文本，图像，音频，视频等多种多媒体格式的结合，比如HTML)的**应用层协议**。协议诞生的初衷是为了定义浏览器和web服务器之间通信的传输格式，便于两者之间的数据传输和解析。

HTTP协议的整体架构是一个典型的**client-server**模型。例如，我们在浏览器打开了一次网页，就是浏览器作为客户端，向远端的web服务端发起了一次或者一系列的资源请求，并且由浏览器解析服务端的应答，最终在浏览器端完成网页内容的展示。

![网页请求简单示意](/docs/network/http/resource/fetch-a-page.drawio.svg)

最开始的HTTP是一个无状态协议(Stateless), 也就是说，处理多次请求的服务端是不会维护任何有关会话的数据的，且前后两次请求，没有直接的关联，但是 Cookie机制的出现打破了这一规则(1994由Netscape提出，在1999年的HTTP/1.1中正是被纳入协议标准)。在这里，我们不详细介绍这个机制，后续会有专门的章节来解释这个工作机制。

在HTTP中，客户端和服务端之间是通过独立的消息格式完成通信的，而不是简单的数据流，通常来说，我们把客户端向服务端的消息叫做请求(requests), 而服务端向客户端发送的数据叫做响应(response)。

## 2 协议栈分布

前面我们介绍到，HTTP是一个应用层协议，由于文档传输需要高可靠性，所有HTTP的底层协议是使用的TCP协议(不包括HTTP/3.0), 其次在HTTP的演进过程中，为了避免在不信任网络中直接使用明文传输以及防止中间人攻击等网络安全问题，在HTTP的基础上诞生了HTTPS，HTTPS主要是使用了基于TCP的TLS协议，下面是一个HTTP在协议栈的一个位置分布：

![HTTP在协议栈分布示意](/docs/network/http/resource/http-layers.drawio.svg)

## 3 系统组成

HTTP是一个基于CS架构模型的一个协议，这就意味着，协议的交互模式，必须由客户端实体，或者一个客户端的代理对象发起请求，由服务端解析请求并对客户端进行响应。通常，我们把这个客户端叫做 user agent, 它可能是一个浏览器，也有可能是一个可以模拟发起http请求的程序(例如爬虫程序，`postman`， `nghttp`等等)。

在请求真正抵达服务端之前，可能会经过网关和缓存服务器等其他网络实体，我们通常把它们叫做`proxies`。
因此，整个请求的处理过程看起来可能是下图这样的：

![各个实体间的简单交互示意](/docs/network/http/resource/client-server-chain.drawio.svg)

接下来，我们再详细讨论再HTTP系统里面，各个实体的角色和分工：

### 3.1 Client(user agent)

HTTP客户端，也可以被称之为用户代理(user agent)，通常来说是浏览器，当然它也可能是一个爬虫程序，一个客户端程序，或者开发人员的调试工具，以及自定义能够模拟HTTP请求的一些调试程序。一般来说，请求都是由客户端首先发起的，它的主要职责是代理用户请求，并完成服务器响应的解析。一个典型的场景就是用户通过域名访问某个网站的首页，服务端收到请求后返回网页的html信息，客户端负责将响应解析为`html`并在浏览器完成界面展示。

### 3.2 Server

HTTP服务端，通常是用来托管网络资源(例如视频网站等)或者提供特殊网络服务(例如缓存服务，数据库服务，电商服务)的一台机器，或者是一组实现负载均衡的服务器集群。

### 3.3 Proxies

代理（Proxies）是位于客户端和服务器之间的网络实体，是一种消息抵达服务端应用之前，一种提前处理请求的一种手段。代理可以是透明的（例如缓存服务），也可以是不透明的（例如重定向服务，网关代理等），代理可以发挥的作用如下：

代理可以是透明的，即转发它们收到的请求并不做任何修改，也可以表现得不透明，将它传递给服务端之前使用一些手段修改这个请求。代理可以发挥很多种作用：

- 缓存（可以是公开的也可以是私有的，如浏览器的缓存）
- 过滤（如反病毒扫描、家长控制...）
- 负载均衡（让多个服务器服务不同的请求）
- 认证（控制对不同资源的访问）
- 日志（使得代理可以存储历史信息）
