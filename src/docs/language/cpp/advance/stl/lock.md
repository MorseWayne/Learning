---
title: 锁介绍
icon: /assets/icons/article.svg
order: 1
category:
  - C++
---

# Lock

## 1 前言

**什么是锁，为什么需要锁？**

我们知道，线程是操作系统调度的最小单位，多个线程可以并发的执行，并在过程中读写一些线程间的共享数据，读写数据同时发生，可能会导致数据读取异常(读到不完整的数据，或者读到脏数据等等)，或者是说某一时间，我只希望单个线程执行一段特定逻辑，这个时候，我们需要一种机制使多个线程串行化的执行读写数据或者是执行其他任务，于是锁，信号量，条件变量等用于管理操作系统中多线程或者多进程并发访问的工具诞生了，这一类工具，我们也称之于 `同步原语` (synchronization primitives);

那么锁是什么？

* **物理锁的本质：** 在现实世界中，锁（比如门锁、保险柜锁）的核心作用是**控制对某个受限资源（如房间、物品）的访问权**。拥有钥匙（权限）的人可以“解锁”并使用资源，用完后再“上锁”，**阻止他人同时进入或触碰**。
* **编程锁的本质：** 在多线程环境中，“锁”机制的核心作用同样是**控制对某个受限资源（如共享变量、数据结构）的并发访问权**。拥有锁的线程可以“获得锁”（加锁）并进入“临界区”（操作资源），操作完后“释放锁”（解锁），**阻止其他线程同时进入该临界区进行操作**。
* **关键映射：** “获得锁 = 开门进入房间”，“释放锁 = 关门上锁”，“临界区 = 房间里的东西”，“其他线程 = 想进入房间的其他人”。这个**访问控制、排他性的概念**与物理锁**完全一致**。

简单来说，上锁就是为了通过一种排他性的“持有-释放”机制来控制对共享资源的访问权，就像物理锁控制对物理空间的访问一样。

## 📊 锁分类总结表

<table><thead><tr><th width="154.6666259765625">分类维度</th><th width="143">类别</th><th width="389.9998779296875">核心特征</th><th width="320">优点</th><th width="292.6666259765625">缺点</th></tr></thead><tbody><tr><td><strong>互斥性</strong></td><td>🔒 <strong>互斥锁</strong></td><td>一次仅允许一个线程持有锁 (绝对排他)</td><td>简单可靠，保证数据完整性和操作原子性</td><td>并发度低，可能成为瓶颈</td></tr><tr><td></td><td>📚 <strong>非互斥锁</strong></td><td>允许多个线程以特定方式持有锁</td><td>提高特定场景(尤其读多写少)的并发度</td><td>比互斥锁复杂，读写锁需区分读写模式</td></tr><tr><td><strong>可重入性</strong></td><td>🔄 <strong>可重入锁</strong></td><td>持有锁的线程可多次成功获取同一锁 (避免自死锁)</td><td>支持在同步代码中递归调用需要同一锁的函数/方法</td><td>实现稍复杂，内部需维护持有计数和线程标识</td></tr><tr><td></td><td>🔐 <strong>非可重入锁</strong></td><td>持有锁的线程再次获取同一锁会死锁/阻塞</td><td>可能更简单或轻量</td><td>极易因递归调用导致死锁</td></tr><tr><td><strong>公平性策略</strong></td><td>🎯 <strong>公平锁</strong></td><td>按线程请求锁的顺序分配锁</td><td><strong>理论上避免饥饿</strong>(所有线程最终得执行)</td><td><strong>性能通常较低</strong> (维护队列, 顺序唤醒, 上下文切换多)</td></tr><tr><td></td><td>🚀 <strong>非公平锁</strong></td><td>不严格按请求顺序分配锁, 新到请求或等待线程可能竞争抢到锁 ("插队")</td><td><strong>通常性能更高</strong> (尤其高竞争时)</td><td>可能导致<strong>线程饥饿</strong>(某个线程长时间抢不到锁)</td></tr><tr><td><strong>阻塞行为</strong></td><td>😴 <strong>阻塞锁</strong></td><td>获取失败时<strong>线程挂起</strong>(阻塞), 不消耗CPU, 等待唤醒</td><td>适合持有锁时间较长的操作</td><td><strong>上下文切换开销大</strong>, 可能无限期等待</td></tr><tr><td></td><td>⏱️ <strong>自旋锁</strong></td><td>获取失败时<strong>忙等待(CPU空转)</strong>, 不断检查锁状态</td><td><strong>锁持有极短</strong>时获取<strong>极快</strong> (省上下文切换)</td><td><strong>持锁时间长时极其浪费CPU</strong>, 单核无意义</td></tr><tr><td></td><td>✨ <strong>乐观锁</strong></td><td>无锁机制: 使用<strong>版本号/CAS</strong>, 检查冲突才重试</td><td><strong>无阻塞</strong>, <strong>高并发</strong>(无争用/低争用时)</td><td>冲突高时<strong>重试开销大</strong>, 需要应用程序处理冲突</td></tr><tr><td><strong>并发控制范式</strong></td><td>😢悲观锁</td><td><p>​<strong>​“先加锁，后操作”​</strong>​<br>假设冲突必然发生，操作共享资源前必须获得锁，确保独占访问。</p><p><strong>C++ 中绝大多数锁机制都属于此范式！​</strong></p></td><td><strong>简单直接，保证强一致性</strong>。</td><td>​ 加锁开销、死锁风险、阻塞可能。</td></tr><tr><td></td><td>✨ <strong>乐观锁</strong></td><td>​<strong>​“先操作，后验证”​</strong>​<br>假设冲突罕见，先无锁进行读写操作，提交前验证数据是否被修改（如版本号/CAS）。若冲突则重试/处理。</td><td>​<strong>无锁或轻锁，高并发潜力</strong>。</td><td>冲突处理逻辑复杂，重试开销（高冲突时），弱一致性可能。</td></tr><tr><td>​<strong>作用域层级</strong></td><td>🌐分布式锁</td><td>协调<strong>跨进程/跨机器</strong>对共享资源（如文件、数据库记录、服务）的访问。</td><td><strong>解决网络分区、节点故障下的全局互斥</strong>。</td><td><strong>核心挑战：​</strong>​ 时钟漂移、脑裂、锁释放（租约/心跳）。</td></tr><tr><td></td><td><strong>📁</strong>数据库锁</td><td>DBMS 内部实现的锁机制，粒度更细（表锁、页锁、行锁、意向锁）</td><td>​<strong>ACID 事务保障的核心</strong>。<br>隔离级别（RU, RC, RR, Serializable）直接影响锁策略。<br>意向锁提升并发（表级 IS/IX）。</td><td>隔离级别（RU, RC, RR, Serializable）直接影响锁策略。</td></tr></tbody></table>

## 🔒 C++ 锁机制分类详解

| 分类维度         | 类型/工具                     | 核心特性                                                                 | 适用场景                                                             |
|------------------|-------------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| **基础互斥类型** | `std::mutex`                  | 基础互斥锁，独占访问                                                     | 简单临界区保护                                                       |
|                  | `std::recursive_mutex`        | 可重入互斥锁，允许同一线程多次加锁                                       | 递归函数/类内互斥调用                                               |
| **读写锁**       | `std::shared_mutex`           | 读写分离：多线程共享读，单线程独占写                                     | **读多写少**场景 (配置读取/数据缓存)                                |
|                  | `std::shared_timed_mutex`     | 支持超时功能的读写锁                                                     | 读多写少+需要加锁超时控制                                           |
| **超时锁变体**   | `std::timed_mutex`            | 支持超时的基础互斥锁                                                     | 避免死锁阻塞 (实时系统/网络超时)                                     |
|                  | `std::recursive_timed_mutex`  | 支持超时的可重入锁                                                       | 递归调用+超时需求                                                   |
| **RAII 管理工具** | `std::lock_guard`             | 作用域锁：构造时自动加锁，析构自动解锁                                   | **简单作用域**锁定 (推荐默认使用)                                   |
|                  | `std::unique_lock`            | 灵活锁：支持延迟加锁、转移所有权、条件变量配合、手动解锁                 | **复杂锁管理** (条件变量/锁策略/多锁协同)                            |
|                  | `std::shared_lock`            | 共享锁守卫：配合 `shared_mutex` 实现自动读锁管理                         | 读写锁的读模式保护                                                   |
| **高级同步原语** | `std::atomic`                 | 无锁原子操作：硬件级指令保证操作原子性 (CAS/TAS)                         | 简单标志位/计数器 **高性能无锁场景**                                |
|                  | `std::atomic_flag`            | 轻量原子标志：唯一保证无锁的原子类型                                     | 自旋锁/低开销互斥实现基础                                           |
|                  | `std::counting_semaphore`     | 计数信号量：控制 N 个资源的并发访问                                      | 连接池/缓冲区槽位管理                                               |
| **线程局部存储** | `thread_local`                | 线程私有变量：每个线程拥有独立副本                                       | **线程独立状态** (ID/缓存/上下文) 彻底避免同步                      |
| **多锁协同工具** | `std::lock()`                 | 多锁死锁回避：原子化锁定多个互斥量                                       | **同时获取多个锁** 避免死锁链风险                                    |
|                  | `std::try_lock()`             | 非阻塞多锁尝试                                                           | 避免阻塞的多锁获取                                                   |