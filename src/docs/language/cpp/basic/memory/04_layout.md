---
title: 程序的内存布局
icon: /assets/icons/article.svg
order: 3
category:
  - C++
---

当一个 C++ 程序被操作系统加载到内存后，操作系统会为它分配一个**独立的虚拟地址空间**。这样做的好处是：每个进程都拥有彼此隔离的运行环境，不会直接干扰其他进程的内存，既保证了安全性，也方便操作系统进行内存管理和调度。

在这个虚拟地址空间中，不同的内存区域有着各自的职责，就像一座工厂里不同的车间专门负责不同的生产任务。下表总结了这些区域的结构、作用及它们为何这么设计（以 32 位或简化的 64 位模型为例）：

| 区域                       | 说明                                    | 特点                               | 设计原因                                   | 增长方向     |
| -------------------------- | --------------------------------------- | ---------------------------------- | ------------------------------------------ | ------------ |
| **代码段 (.text)**         | 存放程序的机器指令                      | 只读，可共享，防止被意外修改       | 保障代码安全性和多进程共享效率             | 固定         |
| **已初始化数据段 (.data)** | 存放已初始化的全局/静态变量             | 可读写                             | 提前分配并初始化，方便快速访问             | 固定         |
| **未初始化数据段 (.bss)**  | 存放未初始化的全局/静态变量，启动时清零 | 可读写                             | 节省可执行文件大小，启动时由系统统一清零   | 固定         |
| **堆 (Heap)**              | 动态分配内存（`new` / `malloc`）        | 程序员手动分配与释放，易内存泄漏   | 提供灵活的内存分配能力，满足运行时变化需求 | 向高地址增长 |
| **内存映射区**             | 动态库、文件映射、共享内存等            | 灵活，可按需加载                   | 支持动态加载功能和高效的文件/进程间通信    | 不固定       |
| **栈 (Stack)**             | 函数调用帧、局部变量、参数、返回地址    | 系统自动管理，空间有限，可能栈溢出 | 提供快速的内存分配与释放机制，保证调用有序 | 向低地址增长 |
