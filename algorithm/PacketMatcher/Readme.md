给定一个数据包，对报文的某一段内容按用户配置规则进行匹配，匹配成功后输出命中规则的ID
规则定义如下：

| 规则id   | 类型       | 定义                                                         |
| -------- | ---------- | ------------------------------------------------------------ |
| `id`     | `uint8_t`  | 正数<br />规则小于等于127时，匹配到该规则不再进行后续规匹配<br />规则大于127时，匹配到该规则需要继续进行后续匹配 |
| `offset` | `uint16_t` | 用于指定需要从报文的某个偏移开始进行匹配                     |
| `len`    | `uint8_t`  | 需要进行匹配的报文长度，长度只有`1/2/4/6/8`                  |
| `min`    | `uint64_t` | 将匹配段转换成数值后，不小于该值表示匹配                     |
| `max`    | `uint64_t` | 将匹配段转换成数值后，不大于该值表示匹配，如果等于，表示精确匹配 |
| `non`    | `uint8_t`  | 该规则是否进行取非，如果为0代表需要取非，取非后，数值小于min，大于max表示匹配 |

下面给定输入示例

**规则输入示例1**：

```
1 2 0 1 1 1 0 3 2 22 22 0

128 4 0 1 2 2 0 2 1 3 3 0 5 2 80 80 0 11 4 180184321 180184575 0

3 2 27 1 6 6 0 2 1 0 2 1
```

**第一行输入解析**：

第一个数字1，代表如果该规则命中，则将执行动作1(满足小于等于127)，无需继续匹配后续规则；
第二个数字2，表示该规则一共需要匹配2个条件；
第三到七个数字（0 1 1 1 0）,表示第一个条件需要匹配报文偏移为0字节，长度为1字节的数据内容，最小值和最大值都为1，不取非，表示精确匹配等于1；
第八到十二个数字（3 2 22 22 0）,表示第二个条件需要匹配报文偏移为3字节，长度为2字节的数据内容，最小值和最大值都为22，表示精确匹配等于22；

**第二行输入解析**：

第一个数字128，代表如果该规则命中，则将执行动作128后继续匹配后续规则；
第二个数字4，表示该规则一共需要匹配4个条件；
第三到七个数字（0 1 2 2 0）,表示第一个条件需要匹配报文偏移为0字节，长度为1字节的数据内容，最小值和最大值都为2，表示精确匹配等于2；
第八到12个数字（2 1 3 3 0),表示第二个条件需要匹配报文偏移为2字节，长度为1字节的数据内容，最小值和最大值都为3，表示精确匹配等于3；
第13到18个数字（5 2 80 80 0),表示第三个条件需要匹配报文偏移为5字节，长度为2字节的数据内容，最小值和最大值都为80，表示精确匹配等于80；
第19到24个数字（11 4 180184321 180184575 0),表示第四个条件需要匹配报文偏移为11字节，长度为4字节的数据内容，表示范围匹配[180184321，180184575]区间的内容；

**第三行输入解析**：

第一个数字3，代表如果该规则命中，则将执行动作3，无需继续匹配后续规则；
第二个数字2，表示该规则一共需要匹配2个条件；
第三到七个数字（27 1 6 6 0）,表示第一个条件需要匹配报文偏移为27字节，长度为1字节的数据内容，最小值和最大值都为6，表示精确匹配等于6；
第八到12个数字（2 1 0 2 1）,表示第一个条件需要匹配报文偏移为2字节，长度为1字节的数据内容，最小值0和最大值2，需要**取非**，表示匹配范围非[0,2]区间的内容；

**测试用例**

```
规则输入示例1：
1 2 0 1 1 1 0 3 2 22 22 0
128 4 0 1 2 2 0 2 1 3 3 0 5 2 80 80 0 11 4 180184321 180184575 0
3 2 27 1 6 6 0 2 1 0 2 1
报文示例：
1 2 0 22 0 23 0 1 101 189 10 255 101 189 10 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 3 142 2 80 0 1 101 189 10 250 101 189 10 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 3 142 2 80 0 1 101 189 10 250 101 189 10 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 0 3 142 2 80 0 1 101 189 10 250 101 189 10 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
输出样例 1
[1]
[128]
[128,3]
[0]
```

## 优化思路

### 思路1：

如果尽可能找到极大概率不符合条件的，就可以减少检查了

哪些可能不太符合条件

1. 匹配报文的内容长的
2. 匹配的目标值的范围少的

### 思路2：

先计算短的，然后根据短的推算新的

例如存在规则1和规则2

规则1判断的是 `offset`：1，`len`：1

规则2判断的是 offset: 1, `len`: 3 , 那么可以尝试从`规则1`推断出`规则2`

**思路3：**

按字节处理报文

将offset作为key，规则id作为value，放入到一个map，

挑选offset出现在公共规则次数多的进行计算

**思路4：**

将所有长度规则缩放到1进行比较
