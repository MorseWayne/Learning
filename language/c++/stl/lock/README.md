# Lock

## 1 前言

**什么是锁，为什么需要锁？**

 我们知道，线程是操作系统调度的最小单位，多个线程可以并发的执行，并在过程中读写一些线程间的共享数据，读写数据同时发生，可能会导致数据读取异常(读到不完整的数据，或者读到脏数据等等)，或者是说某一时间，我只希望单个线程执行一段特定逻辑，这个时候，我们需要一种机制使多个线程串行化的执行读写数据或者是执行其他任务，于是锁，信号量，条件变量等用于管理操作系统中多线程或者多进程并发访问的工具诞生了，这一类工具，我们也称之于 `同步原语` (synchronization primitives);

那么锁是什么？

* **物理锁的本质：** 在现实世界中，锁（比如门锁、保险柜锁）的核心作用是**控制对某个受限资源（如房间、物品）的访问权**。拥有钥匙（权限）的人可以“解锁”并使用资源，用完后再“上锁”，**阻止他人同时进入或触碰**。
* **编程锁的本质：** 在多线程环境中，“锁”机制的核心作用同样是**控制对某个受限资源（如共享变量、数据结构）的并发访问权**。拥有锁的线程可以“获得锁”（加锁）并进入“临界区”（操作资源），操作完后“释放锁”（解锁），**阻止其他线程同时进入该临界区进行操作**。
* **关键映射：** “获得锁 = 开门进入房间”，“释放锁 = 关门上锁”，“临界区 = 房间里的东西”，“其他线程 = 想进入房间的其他人”。这个**访问控制、排他性的概念**与物理锁**完全一致**。

简单来说，上锁就是为了通过一种排他性的“持有-释放”机制来控制对共享资源的访问权，就像物理锁控制对物理空间的访问一样。

## 📊 锁分类总结表

<table><thead><tr><th width="110.6666259765625">分类维度</th><th width="143">类别</th><th width="227.333251953125">核心特征</th><th width="320">优点</th><th width="292.6666259765625">缺点</th></tr></thead><tbody><tr><td><strong>互斥性</strong></td><td>🔒 <strong>互斥锁</strong></td><td>一次仅允许一个线程持有锁 (绝对排他)</td><td>简单可靠，保证数据完整性和操作原子性</td><td>并发度低，可能成为瓶颈</td></tr><tr><td></td><td>📚 <strong>非互斥锁</strong></td><td>允许多个线程以特定方式持有锁</td><td>提高特定场景(尤其读多写少)的并发度</td><td>比互斥锁复杂，读写锁需区分读写模式</td></tr><tr><td><strong>可重入性</strong></td><td>🔄 <strong>可重入锁</strong></td><td>持有锁的线程可多次成功获取同一锁 (避免自死锁)</td><td>支持在同步代码中递归调用需要同一锁的函数/方法</td><td>实现稍复杂，内部需维护持有计数和线程标识</td></tr><tr><td></td><td>🔐 <strong>非可重入锁</strong></td><td>持有锁的线程再次获取同一锁会死锁/阻塞</td><td>可能更简单或轻量</td><td>极易因递归调用导致死锁</td></tr><tr><td><strong>公平性策略</strong></td><td>🎯 <strong>公平锁</strong></td><td>按线程请求锁的顺序分配锁</td><td><strong>理论上避免饥饿</strong>(所有线程最终得执行)</td><td><strong>性能通常较低</strong> (维护队列, 顺序唤醒, 上下文切换多)</td></tr><tr><td></td><td>🚀 <strong>非公平锁</strong></td><td>不严格按请求顺序分配锁, 新到请求或等待线程可能竞争抢到锁 ("插队")</td><td><strong>通常性能更高</strong> (尤其高竞争时)</td><td>可能导致<strong>线程饥饿</strong>(某个线程长时间抢不到锁)</td></tr><tr><td><strong>阻塞行为</strong></td><td>😴 <strong>阻塞锁</strong></td><td>获取失败时<strong>线程挂起</strong>(阻塞), 不消耗CPU, 等待唤醒</td><td>适合持有锁时间较长的操作</td><td><strong>上下文切换开销大</strong>, 可能无限期等待</td></tr><tr><td></td><td>⏱️ <strong>自旋锁</strong></td><td>获取失败时<strong>忙等待(CPU空转)</strong>, 不断检查锁状态</td><td><strong>锁持有极短</strong>时获取<strong>极快</strong> (省上下文切换)</td><td><strong>持锁时间长时极其浪费CPU</strong>, 单核无意义</td></tr><tr><td></td><td>✨ <strong>乐观锁 (非锁锁)</strong></td><td>无锁机制: 使用<strong>版本号/CAS</strong>, 检查冲突才重试</td><td><strong>无阻塞</strong>, <strong>高并发</strong>(无争用/低争用时)</td><td>冲突高时<strong>重试开销大</strong>, 需要应用程序处理冲突</td></tr></tbody></table>

### 📊 C++ 视角锁分类总结表

| 分类维度               | 类别                                        | 核心特征与适用场景                                           | C++ 标准库及相关实例                                         | 优点                                                         | 缺点 / 注意事项                                              |
| :--------------------- | :------------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **互斥性 & 基本类型**  | 🔒 **互斥锁 (Mutex)**                        | 基础互斥锁。**独占访问**。临界区操作期间保证数据一致性和原子性。 | `std::mutex`                                                 | 简单、轻量、高效（无竞争或低竞争）。满足多数基本互斥需求。   | 无法区分读写模式。                                           |
|                        | 🔄 **可重入互斥锁 (Recursive Mutex)**        | **允许同一线程多次锁定**。适用于需要递归访问受保护资源的场景（如递归函数）。 | `std::recursive_mutex`                                       | **避免因递归调用导致的自死锁**。                             | **性能略低于 `std::mutex`\**（维护内部递归计数），增加了滥用风险（可能导致其他线程饥饿）。\**非必要时不建议使用**。 |
|                        | 📚 **共享互斥锁 (读写锁 Read-Write Lock)**   | **区分读共享、写独占**。**读多写少**场景提升并发性能（允许多个读者同时访问）。 | `std::shared_mutex` (C++17) `std::shared_timed_mutex` (C++14) *注：`std::shared_timed_mutex` 功能更丰富* | **大幅提高并发读取性能**。                                   | 实现比 `std::mutex` **复杂**。**写锁获取期间会阻塞所有读写操作**。**写操作频率较高或临界区大时可能反而不如 `std::mutex`**。 |
| **所有权管理与 RAII**  | 📘 **`std::lock_guard`**                     | **RAII 守卫**，在其**构造时加锁**，在其**析构时解锁**。适用于简单的临界区作用域锁定。 | `std::lock_guard<MutexType>` (e.g., `lock_guard<mutex>`)     | **简洁、安全**，保证锁**必然释放**，避免忘记解锁导致的死锁。 | **作用域固定**，不灵活（无法提前解锁或在更大范围内转移所有权）。**无法与非作用域锁共用**。 |
|                        | 📗 **`std::unique_lock`**                    | **更灵活的 RAII 守卫**。提供 `std::lock_guard` 所有功能外加： - **延迟加锁**（`defer_lock`） - **尝试加锁**（`try_lock()`） - **定时加锁**（`try_lock_for()`, `try_lock_until()`) (`timed_mutex` 专用) - **提前解锁**（`unlock()`） - **锁所有权转移**（移动语义） | `std::unique_lock<MutexType>`                                | **极其灵活**。支持多种加锁策略、条件变量结合、锁所有权管理（移动语义）。**首选**大多数需要灵活控制锁的场景。 | 相比 `lock_guard` 有**微小性能开销**（维护额外状态）。接口更复杂（但复杂性可控）。 |
| **锁定策略与辅助函数** | 🤹 **`std::lock`**                           | **死锁回避算法**。**一次性原子化锁定多个（至少两个）互斥锁对象**。避免手动按顺序锁定可能导致的死锁（顺序不一致时）。 | `std::lock(mutex1, mutex2, ...)`                             | **安全地锁定多个互斥量**，极大降低多锁场景死锁风险。         | 必须与 `std::lock_guard` 或 `std::unique_lock`（配合 `std::adopt_lock` 策略）**一起使用**以管理锁的生命周期。 |
|                        | 🕒 **`std::try_lock`**                       | **尝试一次性原子化锁定多个互斥锁对象**。成功则锁定所有互斥锁并返回 `-1`，失败则释放所有已锁定的锁并返回第一个失败的索引。 | `std::try_lock(mutex1, mutex2, ...)`                         | **非阻塞方式尝试获取多个锁**，适用于需要避免死锁或不能长时间阻塞的场景。 | 使用相对复杂，需仔细处理返回值。                             |
| **超时功能**           | ⏳ **超时互斥锁 (Timed Mutex)**              | 允许在尝试获取锁时**指定超时时间**或**指定时间点**。避免无限期阻塞。 | `std::timed_mutex` `std::recursive_timed_mutex` `std::shared_timed_mutex` | 提供**避免无限期阻塞**的能力，适用于实时系统或需要响应性的场景。 | **性能可能稍逊于非超时版本**（需要管理时间状态）。**定时加锁操作有一定开销**。 |
| **底层与并发模式**     | 🔄 **自旋锁 (Spinlock)**                     | 获取失败时**忙等待 (CPU 循环检查)**。**假设锁持有时间极短**（如几十到几百纳秒），**避免线程阻塞上下文切换开销**。 | **标准库未提供**（通常基于 `std::atomic_flag` / `std::atomic<bool>` + CAS `compare_exchange_strong` 手动实现） | 在锁**持有时间极短**且**多核环境**下，**性能远超阻塞锁**（省去了昂贵的线程唤醒调度）。 | **锁持有稍长或单核环境：极度浪费 CPU**（线程空转），可能导致**性能骤降**和系统**卡顿**。**谨慎使用！** |
|                        | 🌉 **无锁 (Lock-Free) / 无等待 (Wait-Free)** | **非阻塞**并发控制。依靠**硬件原子操作 (CAS, LL/SC)** 和**内存顺序约束 (`std::memory_order`)** 实现数据同步。目标是确保系统级、线程级或操作级的“进展”。 | `std::atomic<T>`, `std::atomic_flag` `std::atomic_ref` (C++20) 无锁队列/栈实现 | **高并发、低延迟**关键路径。避免死锁、锁优先级反转等问题。增强可扩展性和响应性。 | **实现极其复杂**，需要深厚的并发知识和硬件内存模型理解。需要应用层处理冲突（重试/优雅失败）。**难以调试和验证正确性**。 |
| **其他工具**           | 💾 **线程局部存储 (TLS)**                    | **每个线程拥有独立的变量副本**。消除同步需求。               | `thread_local` 关键字                                        | **零锁开销**，访问速度最快。适合存储线程特有的状态（如线程ID、缓存、计数器等）。 | **仅适用于数据天然是线程私有的场景**。无法直接用于**线程间协作共享状态**。 |
|                        | 🔄 **信号量 (Semaphore)**                    | 基于**资源计数器**的同步原语。控制同时访问**某种资源池**（非单一资源）的线程数量。 | **标准库未提供**（C++20 引入 `std::counting_semaphore`, `std::binary_semaphore`） *Boost/第三方库有提供* | 概念通用，可表示可用资源（如连接池、缓冲区槽位）。           | 与互斥锁目的不同（互斥锁是特殊的二进制信号量）。需要应用层协调。实现不当易出错（比互斥锁更原始）。 |
