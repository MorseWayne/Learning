# 锁机制

## 1 前言

**什么是锁，为什么需要锁？**

​	我们知道，线程是操作系统调度的最小单位，多个线程可以并发的执行，并在过程中读写一些线程间的共享数据，读写数据同时发生，可能会导致数据读取异常(读到不完整的数据，或者读到脏数据等等)，或者是说某一时间，我只希望单个线程执行一段特定逻辑，这个时候，我们需要一种机制使多个线程串行化的执行读写数据或者是执行其他任务，于是锁，信号量，条件变量等用于管理操作系统中多线程或者多进程并发访问的工具诞生了，这一类工具，我们也称之于 `同步原语` (synchronization primitives);

那么锁是什么？

- **物理锁的本质：** 在现实世界中，锁（比如门锁、保险柜锁）的核心作用是**控制对某个受限资源（如房间、物品）的访问权**。拥有钥匙（权限）的人可以“解锁”并使用资源，用完后再“上锁”，**阻止他人同时进入或触碰**。
- **编程锁的本质：** 在多线程环境中，“锁”机制的核心作用同样是**控制对某个受限资源（如共享变量、数据结构）的并发访问权**。拥有锁的线程可以“获得锁”（加锁）并进入“临界区”（操作资源），操作完后“释放锁”（解锁），**阻止其他线程同时进入该临界区进行操作**。
- **关键映射：** “获得锁 = 开门进入房间”，“释放锁 = 关门上锁”，“临界区 = 房间里的东西”，“其他线程 = 想进入房间的其他人”。这个**访问控制、排他性的概念**与物理锁**完全一致**。

简单来说，上锁就是为了通过一种排他性的“持有-释放”机制来控制对共享资源的访问权，就像物理锁控制对物理空间的访问一样。

## 📊 锁分类总结表 

| 分类维度       | 类别                  | 核心特征                                                     | 典型代表/应用场景                                            | 优点                                            | 缺点                                                |
| :------------- | :-------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------------------- | :-------------------------------------------------- |
| **互斥性**     | 🔒 **互斥锁**          | 一次仅允许一个线程持有锁 (绝对排他)                          | `pthread_mutex_t`, `std::mutex`, `synchronized`, `ReentrantLock` | 简单可靠，保证数据完整性和操作原子性            | 并发度低，可能成为瓶颈                              |
|                | 📚 **非互斥锁**        | 允许多个线程以特定方式持有锁                                 | **读写锁** (`pthread_rwlock_t`, `ReentrantReadWriteLock`) - **允许多读/单写** **信号量** (`sem_t`, `Semaphore`) - **控制有限资源池访问** | 提高特定场景(尤其读多写少)的并发度              | 比互斥锁复杂，读写锁需区分读写模式                  |
| **可重入性**   | 🔄 **可重入锁**        | 持有锁的线程可多次成功获取同一锁 (避免自死锁)                | Java `synchronized`, `ReentrantLock`, `pthread_mutex` (设置`RECURSIVE`) | 支持在同步代码中递归调用需要同一锁的函数/方法   | 实现稍复杂，内部需维护持有计数和线程标识            |
|                | 🔐 **非可重入锁**      | 持有锁的线程再次获取同一锁会死锁/阻塞                        | 简单的`std::mutex` (非递归), 某些低级锁                      | 可能更简单或轻量                                | 极易因递归调用导致死锁                              |
| **公平性策略** | 🎯 **公平锁**          | 按线程请求锁的顺序分配锁                                     | `ReentrantLock(true)`                                        | **理论上避免饥饿**(所有线程最终得执行)          | **性能通常较低** (维护队列, 顺序唤醒, 上下文切换多) |
|                | 🚀 **非公平锁**        | 不严格按请求顺序分配锁, 新到请求或等待线程可能竞争抢到锁 ("插队") | Java `synchronized`, `ReentrantLock()` (默认), `std::mutex`  | **通常性能更高** (尤其高竞争时)                 | 可能导致**线程饥饿**(某个线程长时间抢不到锁)        |
| **阻塞行为**   | 😴 **阻塞锁**          | 获取失败时**线程挂起**(阻塞), 不消耗CPU, 等待唤醒            | `std::mutex.lock()`, `ReentrantLock.lock()`, `synchronized`  | 适合持有锁时间较长的操作                        | **上下文切换开销大**, 可能无限期等待                |
|                | ⏱️ **自旋锁**          | 获取失败时**忙等待(CPU空转)**, 不断检查锁状态                | `pthread_spinlock_t`, 内核低级锁                             | **锁持有极短**时获取**极快** (省上下文切换)     | **持锁时间长时极其浪费CPU**, 单核无意义             |
|                | 🚫 **非阻塞尝试获取**  | `tryLock()`: 试一次, 成功则持有, 失败则立即返回 (不阻塞)     | `std::mutex::try_lock()`, `ReentrantLock.tryLock()`          | 实现逻辑控制 (如避免死锁, 有限重试, 非阻塞操作) | 可能一次试不到                                      |
|                | ✨ **乐观锁 (非锁锁)** | 无锁机制: 使用**版本号/CAS**, 检查冲突才重试                 | 数据库MVCC, `AtomicInteger`, `LongAdder`                     | **无阻塞**, **高并发**(无争用/低争用时)         | 冲突高时**重试开销大**, 需要应用程序处理冲突        |
